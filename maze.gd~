tool
extends StaticBody

export(int, 2, 25) var size_x = 5 setget set_size_x
export(int, 2, 25) var size_y = 5 setget set_size_y
export(float) var width = 4.0
export(float) var wall_width = 0.1
export(float) var height = 2.6
export(int) var random_seed = 0 setget set_random_seed
export(Material) var wall_material
var cells = []

const DIRECTIONS = [ { x=-1, y=0, r=1 }, { x=0, y=-1, r=0 }, { x=1, y=0, r=1 }, { x=0, y=1, r=0 } ]
const DIRECTION_LEFT  = 0
const DIRECTION_UP    = 1
const DIRECTION_RIGHT = 2
const DIRECTION_DOWN  = 3
const MASK_VISITED    = 16

func _ready():
	generate()

func set_size_x(s):
	size_x = s
	generate()

func set_size_y(s):
	size_y = s
	generate()

func set_random_seed(s):
	random_seed = s
	generate()

func generate():
	seed(random_seed)
	# Remove existing walls
	for c in get_children():
		if c.name != "Config":
			c.queue_free()
	# Initialize grid
	cells = []
	for x in range(size_x):
		var line = []
		for y in range(size_y):
			line.append(0)
		cells.append(line)
	# Generate maze
	var current = { x=0, y=0 }
	var remaining = size_x*size_y-1
	var stack = []
	cells[current.x][current.y] |= 1 | MASK_VISITED
	while remaining > 0:
		var choices = []
		for d in range(4):
			var x = current.x+DIRECTIONS[d].x
			var y = current.y+DIRECTIONS[d].y
			if x >= 0 && y >= 0 && x < size_x && y < size_y && (cells[x][y] & MASK_VISITED) == 0:
				choices.append(d)
		if choices.empty():
			current = stack.pop_back()
		else:
			var d = choices[randi() % choices.size()]
			stack.append(current.duplicate())
			cells[current.x][current.y] |= (1 << d)
			current.x += DIRECTIONS[d].x
			current.y += DIRECTIONS[d].y
			cells[current.x][current.y] |= (1 << ((d + 2) % 4)) | MASK_VISITED
			remaining -= 1
	# Instanciate walls
	if 0:
		for x in range(cells.size()):
			var line = cells[x]
			for y in range(line.size()):
				var c = line[y]
				for d in range(4):
					if c & (1 << d) == 0 && (x == 0 || DIRECTIONS[d].x != -1)  && (y == 0 || DIRECTIONS[d].y != -1):
						var wall = preload("res://wall.tscn").instance()
						add_child(wall)
						wall.translation = width*Vector3(x+0.5*DIRECTIONS[d].x, 0.0, y+0.5*DIRECTIONS[d].y)
						wall.rotation.y = 0.5*PI*DIRECTIONS[d].r
	# Generate walls
	var context = { vertices=[ ], uvs=[ ] }
	generate_walls_along_x(0, DIRECTION_UP, context)
	for y in range(size_y):
		generate_walls_along_x(y, DIRECTION_DOWN, context)
	generate_walls_along_y(0, DIRECTION_LEFT, context)
	for x in range(size_x):
		generate_walls_along_y(x, DIRECTION_RIGHT, context)
	var mesh_instance = MeshInstance.new()
	mesh_instance.mesh = ArrayMesh.new()
	mesh_instance.mesh.add_surface_from_arrays(ArrayMesh.PRIMITIVE_TRIANGLES, [ PoolVector3Array(context.vertices), null, null, null, null, null, null, null, null ])
	mesh_instance.mesh.surface_set_material(0, wall_material)
	add_child(mesh_instance)

func create_rect(from, to, context):
	var uv_from = from.y
	var uv_to = to.y
	if abs(from.x-to.x) > abs(from.y-to.y):
		uv_from = from.x
		uv_to = to.x
	context.vertices.append(Vector3(from.x, 0, from.y))
	context.uvs.append(Vector3(uv_from, 0))
	context.vertices.append(Vector3(from.x, height, from.y))
	context.uvs.append(Vector3(uv_from, height))
	context.vertices.append(Vector3(to.x, 0, to.y))
	context.uvs.append(Vector3(uv_to, 0))
	context.vertices.append(Vector3(from.x, height, from.y))
	context.uvs.append(Vector3(uv_from, height))
	context.vertices.append(Vector3(to.x, height, to.y))
	context.uvs.append(Vector3(uv_to, height))
	context.vertices.append(Vector3(to.x, 0, to.y))
	context.uvs.append(Vector3(uv_to, 0))

func create_wall(from, to, context):
	create_rect(Vector2(from.x, from.y), Vector2(from.x, to.y), context)
	create_rect(Vector2(from.x, to.y), Vector2(to.x, to.y), context)
	create_rect(Vector2(to.x, to.y), Vector2(to.x, from.y), context)
	create_rect(Vector2(to.x, from.y), Vector2(from.x, from.y), context)
	var center = 0.5*(from+to)
	var extent = to-center
	var shape = CollisionShape.new()
	shape.translation = Vector3(center.x, 0.5*height, center.y)
	shape.shape = BoxShape.new()
	shape.shape.extents = Vector3(extent.x, 0.5*height, extent.y)
	add_child(shape)

func generate_walls_along_x(y, d, context):
	var mask = (1 << d)
	var offset = 0.5*Vector2(DIRECTIONS[d].x, DIRECTIONS[d].y)
	var wall_begin = null
	for x in range(size_x):
		if wall_begin == null && (cells[x][y] & mask) == 0:
			wall_begin = x
		elif wall_begin != null && (cells[x][y] & mask) != 0:
			create_wall(width*(Vector2(wall_begin-0.5, y)+offset)-0.5*wall_width*Vector2(1, 1), width*(Vector2(x-0.5, y)+offset)+0.5*wall_width*Vector2(1, 1), context)
			wall_begin = null
	if wall_begin != null:
		create_wall(width*(Vector2(wall_begin-0.5, y)+offset)-0.5*wall_width*Vector2(1, 1), width*(Vector2(size_x-0.5, y)+offset)+0.5*wall_width*Vector2(1, 1), context)

func generate_walls_along_y(x, d, context):
	var mask = (1 << d)
	var offset = 0.5*Vector2(DIRECTIONS[d].x, DIRECTIONS[d].y)
	var wall_begin = null
	for y in range(size_y):
		if wall_begin == null && (cells[x][y] & mask) == 0:
			wall_begin = y
		elif wall_begin != null && (cells[x][y] & mask) != 0:
			create_wall(width*(Vector2(x, wall_begin-0.5)+offset)-0.5*wall_width*Vector2(1, 1), width*(Vector2(x, y-0.5)+offset)+0.5*wall_width*Vector2(1, 1), context)
			wall_begin = null
	if wall_begin != null:
		create_wall(width*(Vector2(x, wall_begin-0.5)+offset)-0.5*wall_width*Vector2(1, 1), width*(Vector2(x, size_y-0.5)+offset)+0.5*wall_width*Vector2(1, 1), context)
